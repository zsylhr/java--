# 1.我看你在项目中有用到redis，你们主要使用场景有哪些呢？
在我们的业务中，主要使用redis做缓存和分布式锁。（除此之外，redis还可以用来做计数器、保存token、消息队列以及延时队列）

# 2.我看你有说到使用redis做缓存的场景，那么你知道什么是缓存穿透、击穿、雪崩吗？遇见这些情况怎么解决？
a.缓存穿透指的是：比如我有一个查询请求，查询id为1000对应的数据，在查询的过程中，先对redis缓存进行查询，查询不到之后接着对DB进行查询，依然查询不到，并且这种情况下不会写入缓存，导致之后的每次请求都会查DB，这种情况就叫做缓存穿透。
对于这种情况通常有两种解决办法：
一是在redis中缓存null值，也就是说每次查DB查询不到时，都向redis中写入一个{"id":xxx, "value":null}的键值对，这样之后再查询就会在缓存处直接返回null了，但是这样做会有一些问题，比如我们的网站被攻击时，别人可能会使大量非重复的查询，这样我们的redis中就会写入大量空值，内存压力上升，同时非重复的查询依然会查DB, DB的压力还是很大，而且之后如果这些key如果在数据库中有值了，也有可能会导致数据不一致的问题。
在我们的项目中采用的是另一种方法，在查询redis缓存之前添加一个布隆过滤器，布隆过滤器本质上是一个bitmap(位图),或者说是一个位数组，当一个元素被添加进来时，我们通过K个不同的hash函数将这个元素映射为K个不同的hash值，之后将数组中索引为这些hash的设置为1，之后进行查询时只需判断查询元素在数组对应的K个值是否全部为1就行了，从而实现过滤的效果。不过由于hash碰撞的原因，使用布隆过滤器不能百分百过滤数据库中不存在的元素，会有一定的误差率（数组越大误差越小，但是数组带来的内存消耗会变大），不过这个误差率通过设置数组的长度是可以进行控制的。在我们的项目中，设置的误差率是5%，我们觉得这个程度的异常流量访问到DB是可以接受的。

b.缓存击穿指的是给某个key设置了过期时间，然后当这个key过期的时候，同一时间有对这个key有大量并发请求，（在key重新写入redis的几十毫秒内）这些并发请求会访问到DB上，从而大幅增加DB压力，甚至把DB打垮。
这种情况也有两种解决方法：
在我们的业务中，对数据的强一致性要求比较高，使用的是互斥锁的方法。对于刚刚描述的大量请求，当线程1查询缓存未命中时，会去获取互斥锁，获取互斥锁成功后，接着查询DB, 写入缓存，最后释放互斥锁。线程2查询缓存未命中时，也会去获取互斥锁，但此时锁已经被线程1占有，线程2获取互斥锁失败，接着它就会休眠一会儿，然后继续查询缓存，然后获取互斥锁，一直重复这个过程，直至线程1写入缓存之后，线程2查询缓存成功，返回缓存数据。使用互斥锁的好处就是数据的强一致性，但是性能会差一些。
如果对性能要求比较高，对一致性的要求比较低，可以采用逻辑过期的方法。也就是说不给redi中的key设置过期时间，而是在写入redis时，在数据中新增一个过期时间字段，之后通过这个字段来判断是否过期。当线程1查询缓存时，通过这个字段判断已经过期，然后就会去获取一个互斥锁，接着会开启一个线程2，线程2会查询数据库，写入redis，重设过期时间并释放互斥锁，线程1在开启线程2之后，会直接返回redis的过期数据，不会等待线程2的执行完成。同时，当线程3查询缓存时，发现已经过期，并且获取互斥锁也失败，那么会直接返回缓存中的过期数据。这种方法没有等待互斥锁的过程，因此性能比较好，但是会返回过期数据，只能保证高可用性。

c.缓存雪崩指的是设置缓存时设计了相同的过期时间，导致同一时间有大量缓存失效，请求全部转发给了DB,DB压力瞬间增大导致雪崩。此外Redis服务宕机也会导致雪崩
对于同一时间大量缓存失效，我们可以对不同的key设置随机的TTL,让它们的过期时间充满随机性。对于Redis服务宕机，可以提高redis服务的可用性，比如哨兵模式和集群模式。此外还可以采用降级限流的方式，通过配置nginx或者springcloud gateway来实现。此外还可以给我们的业务设置多级缓存
